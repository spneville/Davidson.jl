var documenterSearchIndex = {"docs":
[{"location":"allowed_types/#Allowed-types","page":"Allowed types","title":"Allowed types","text":"","category":"section"},{"location":"allowed_types/#AllowedTypes","page":"Allowed types","title":"Allowed matrix types","text":"","category":"section"},{"location":"allowed_types/#Davidson.AllowedTypes","page":"Allowed types","title":"Davidson.AllowedTypes","text":"AllowedTypes = Union{Float32, Float64, ComplexF32, ComplexF64}\n\nThe allowed types T of the matrix whose eigenpairs are to be computed.\n\n\n\n\n\n","category":"type"},{"location":"allowed_types/#AllowedFloat","page":"Allowed types","title":"Allowed real types","text":"","category":"section"},{"location":"allowed_types/#Davidson.AllowedFloat","page":"Allowed types","title":"Davidson.AllowedFloat","text":"AllowedFloat = Union{Float32, Float64}\n\nThe allowed real number types R that are compatible with the allowed matrix types T\n\n\n\n\n\n","category":"type"},{"location":"allowed_types/#Compatible-types","page":"Allowed types","title":"Compatible types","text":"","category":"section"},{"location":"allowed_types/","page":"Allowed types","title":"Allowed types","text":"The arrays of type R<:AllowedFloat supplied to the solver and solver! functions must be compatible with the arrays of type T<:AllowedTypes. For example, if T==ComplexF64, then it is required that R==Float64. The following table lists the compatible type pairs:","category":"page"},{"location":"allowed_types/","page":"Allowed types","title":"Allowed types","text":"T R\nFloat32 Float32\nFloat64 Float64\nComplexF32 Float32\nComplexF64 Float64","category":"page"},{"location":"work_arrays/#WorkArrays","page":"Creating work arrays","title":"Creating work arrays","text":"","category":"section"},{"location":"work_arrays/#Required-work-arrays","page":"Creating work arrays","title":"Required work arrays","text":"","category":"section"},{"location":"work_arrays/","page":"Creating work arrays","title":"Creating work arrays","text":"The in-place solver! function can be made almost allocation free via the passing of optional pre-allocated work arrays. This can be advantageous if a large number of different diagonalisations are to be performed and the maximum dimensions across all calculations are known ahead of time. The work arrays have a minimum dimension, but not a maximum one. Thus, they can be allocated once, using the maximum dimensions across all calculations to be performed, and then used in every calculation.","category":"page"},{"location":"work_arrays/","page":"Creating work arrays","title":"Creating work arrays","text":"Two work vectors have to be supplied:","category":"page"},{"location":"work_arrays/","page":"Creating work arrays","title":"Creating work arrays","text":"Twork::Vector{T}, where T<:AllowedTypes\nRwork::Vector{R}, where R<AllowedFloat","category":"page"},{"location":"work_arrays/","page":"Creating work arrays","title":"Creating work arrays","text":"where the types T and R are compatible (see Allowed types)","category":"page"},{"location":"work_arrays/#Generating-the-work-arrays","page":"Creating work arrays","title":"Generating the work arrays","text":"","category":"section"},{"location":"work_arrays/","page":"Creating work arrays","title":"Creating work arrays","text":"The required dimensions of the Twork and Rwork vectors are dependent on the size of the matrix being diagonalised, the block size, and the maximum subspace dimension. There exists a function, workarrays, that will return the correctly dimensioned arrays given these values.","category":"page"},{"location":"work_arrays/#Davidson.workarrays","page":"Creating work arrays","title":"Davidson.workarrays","text":"workarrays(T, matdim, blocksize, maxvec)\n\nConstructs the Twork and Rwork work arrays required to make the in-place solver! function allocation-free.\n\nArguments\n\nT<:AllowedTypes: Matrix type\nmatdim::Int64: Dimension of the matrix\nblocksize::Int64: Block size\nmaxvec::Int64: Maximum subspace dimension\n\nReturn values\n\nThe return value is of the form Twork, Rwork = workarrays(…), where\n\nTwork::Vector{T<:AllowedTypes}\nRwork::Vector{R<:AllowedFloat}, where R is compatible with T\n\n\n\n\n\n","category":"function"},{"location":"guess_vectors/#guessvectors","page":"Guess vectors","title":"Guess vectors","text":"","category":"section"},{"location":"guess_vectors/","page":"Guess vectors","title":"Guess vectors","text":"This section details how the guess vectors are constructed.","category":"page"},{"location":"guess_vectors/#Automated-guess-vector-construction","page":"Guess vectors","title":"Automated guess vector construction","text":"","category":"section"},{"location":"guess_vectors/","page":"Guess vectors","title":"Guess vectors","text":"If either the solver function is used, or if the solver! function is used and the keyword argument guess=false, then the guess vectors are constructed automatically. At present, they are simply taken as the unit vectors corresponding to the blocksize lowest-value on-diagonal matrix elements.","category":"page"},{"location":"guess_vectors/#User-supplied-guess-vectors","page":"Guess vectors","title":"User-supplied guess vectors","text":"","category":"section"},{"location":"guess_vectors/","page":"Guess vectors","title":"Guess vectors","text":"If the solver! function is used and the keyword argument guess=true, then the contents of the vectors array will be used to construct the guess vectors. The vectors found are subjected to Lowdin's symmetric orthogonalisation before being set as the guess vectors.","category":"page"},{"location":"guess_vectors/","page":"Guess vectors","title":"Guess vectors","text":"A total of blocksize guess vectors need to be constructed. The number of guess vectors supplied in the vectors array can range from nroots to blocksize. If fewer than blocksize are found, the rest are generated by adding normalised random vectors to the set prior to orthogonalisation. On exit, the first nroots vectors in the vectors array will be the eigenvectors of interest.","category":"page"},{"location":"matvec/#matvec","page":"Matrix-vector multiplication function","title":"Matrix-Vector Multiplication","text":"","category":"section"},{"location":"matvec/","page":"Matrix-vector multiplication function","title":"Matrix-vector multiplication function","text":"This section details the required form of the in-place matrix-vector multiplication function f that the solver and solver! functions take as an argument.","category":"page"},{"location":"matvec/#Arguments-of-the-function-f","page":"Matrix-vector multiplication function","title":"Arguments of the function f","text":"","category":"section"},{"location":"matvec/","page":"Matrix-vector multiplication function","title":"Matrix-vector multiplication function","text":"v::AbstractMatrix{T}: Vectors to be multiplied by the matrix A, where T<:AllowedTypes\nAv::AbstractMatrix{T}: Matrix-vector products, where T<:AllowedTypes","category":"page"},{"location":"matvec/","page":"Matrix-vector multiplication function","title":"Matrix-vector multiplication function","text":"Here, the columns of the matrices v and Av contain the vectors in question.","category":"page"},{"location":"matvec/","page":"Matrix-vector multiplication function","title":"Matrix-vector multiplication function","text":"The function must take the following form, where T<:AllowedTypes:","category":"page"},{"location":"matvec/","page":"Matrix-vector multiplication function","title":"Matrix-vector multiplication function","text":"function f!(v::AbstractMatrix{T}, Av::AbstractMatrix{T})\n\n# The contents of the function will be application-dependent,\n# but the matrix A will be applied to the vectors contained in\n# v to yield the vectors in Av\n\nend","category":"page"},{"location":"solver/#solver","page":"Solvers","title":"solver","text":"","category":"section"},{"location":"solver/","page":"Solvers","title":"Solvers","text":"This section details the use of the solver function, as well as its in-place version solver!. These compute a given number of the lowest-lying eigenpairs of a given matrix A in a 'matrix-free' manner. That is, only a function returning matrix-vector products is required as input, as opposed to the matrix itself.","category":"page"},{"location":"solver/#Davidson.solver","page":"Solvers","title":"Davidson.solver","text":"solver(f, diag, nroots, matdim; tol=1e-4, blocksize=nroots+5,\n       maxvec=4*blocksize, niter=100, verbose=false)\n\nArguments\n\nf::Function: In-place matrix-vector multiplication function\ndiag::Vector{T}: Diagonal of the matrix whose eigenpairs are sought, where T<:AllowedTypes\nnroots::Int64: Number of eigenpairs to compute\nmatdim::Int64: Dimension of the matrix\n\nOptional keyword arguments\n\ntol::Float64: Residual norm convergence threshold\nblocksize::Int64: Block size\nmaxvec::Int64: Maximum subspace dimension\nniter::Int64: Maximum number of iterations\nverbose::Bool: Verbose output flag. If true, then a summary is printed                  at the end of each iteration\n\nReturn values\n\nThe return value is of the form result = solver(…), where result is an EigenPairs object with the following fields:\n\nvectors::Matrix{T}: Eigenvectors\nvalues::Vector{R}: Eigenvalues\nresiduals::Vector{R}: Residual norms of the eigenvectors\nconverged::Vector{Bool}: Convergence flags (converged[i] == true if the i root converged)\n\nwarning: Check for convergence\nIf verbose==false, no warning is printed if one or more roots fail to converge. The contents of result.converged should therefore be checked.\n\nA note on the matrix-vector multiplication function\n\nLet the matrix whose eigenpairs are sought be denoted by A. The in-place Function f recieves takes as arguments an AbstractMatrix{T} of vectors v and an AbstractMatrix{T} of matrix-vector products Av that is to be computed, where T<:AllowedTypes. The required form of this function is detailed in Matrix-vector multiplication function section.\n\n\n\n\n\n","category":"function"},{"location":"solver/#Davidson.solver!","page":"Solvers","title":"Davidson.solver!","text":"solver!(vectors, values, f, diag, nroots, matdim, [Twork, Rwork];\n        tol=1e-4, blocksize=nroots+5, maxvec=4*blocksize, niter=100,\n        verbose=false, guess=false)\n\nArguments\n\nvectors::Matrix{T}: Eigenvectors, where T<:AllowedTypes\nvalues::Vector{R}: Eigenvalues, where R<:AllowedFloat\nf::Function: In-place matrix-vector multiplication function\ndiag::Matrix{T}: Diagonal of the matrix whose eigenpairs are sought, where T<:AllowedTypes\nnroots::Int64: Number of eigenpairs to compute\nmatdim::Int64: Dimension of the matrix\n\nOptional arguments\n\nThe following two pre-allocated work arrays may be supplied:\n\nTwork::Vector{T}: Type T<:AllowedTypes work array\nRwork::Vector{R}: Type R<:AllowedFloat work array\n\nSee Work arrays for the procedure for constructing these.\n\nOptional keyword arguments\n\ntol::Float64: Residual norm convergence threshold\nblocksize::Int64: Block size\nmaxvec::Int64: Maximum subspace dimension\nniter::Int64: Maximum number of iterations\nverbose::Bool: Verbose output flag. If true, then a summary is printed                  at the end of each iteration\nguess::Bool: If true, then on input, the vectors array is taken to                contain the guess vectors\n\nReturn values\n\nThe return value is of the form result = solver!(…), where result is an ConvInfo object with the following fields:\n\nresiduals::Vector{R}: Residual norms of the eigenvectors\nconverged::Vector{Bool}: Convergence flags (converged[i] == true if the i root converged)\n\nwarning: Check for convergence\nIf verbose==false, no warning is printed if one or more roots fail to converge. The contents of result.converged should therefore be checked.\n\n\n\n\n\n","category":"function"},{"location":"#man-davidson","page":"Home","title":"Davidson.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package implementing the Davidson algorithm for the calculation of the lowest-lying eigenpairs of large, sparse, diagonally dominant Hermitian matrices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The implementation is 'matrix-free'. That is, for a given matrix A, the matrix itself does not have to be provided, only a function f that returns the action of A on a set of input vectors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Multiple roots are computed simultaneously using a block variant of the algorithm.","category":"page"}]
}
